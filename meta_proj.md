# T√≥m t·∫Øt ch·ª©c nƒÉng c·ªßa proj
_Exported on 7/1/2025 at 09:06:22 GMT+7 from Cursor (1.1.6)_

---

**User**

ƒë·∫ßu ti√™n h√£y t·ªçc qua proj v√† t√≥m t·∫Øt ch·ª©c nƒÉng

---

**Cursor**

T√¥i s·∫Ω ƒë·ªçc qua d·ª± √°n ƒë·ªÉ hi·ªÉu ch·ª©c nƒÉng v√† t√≥m t·∫Øt cho b·∫°n. H√£y b·∫Øt ƒë·∫ßu v·ªõi vi·ªác xem c√°c file c·∫•u h√¨nh ch√≠nh v√† documentation.

D·ª±a tr√™n vi·ªác ph√¢n t√≠ch c·∫•u tr√∫c d·ª± √°n v√† c√°c file quan tr·ªçng, ƒë√¢y l√† **t√≥m t·∫Øt ch·ª©c nƒÉng c·ªßa MetaMask Mobile**:

## üöÄ **T·ªïng quan d·ª± √°n**

**MetaMask Mobile** l√† ·ª©ng d·ª•ng v√≠ cryptocurrency di ƒë·ªông ch√≠nh th·ª©c c·ªßa MetaMask, ƒë∆∞·ª£c ph√°t tri·ªÉn b·∫±ng **React Native** ƒë·ªÉ h·ªó tr·ª£ c·∫£ iOS v√† Android. ƒê√¢y l√† m·ªôt v√≠ phi t·∫≠p trung (non-custodial wallet) cho ph√©p ng∆∞·ªùi d√πng t∆∞∆°ng t√°c v·ªõi blockchain Ethereum v√† c√°c m·∫°ng t∆∞∆°ng th√≠ch.

## üîß **Ch·ª©c nƒÉng ch√≠nh**

### **1. Qu·∫£n l√Ω V√≠ & T√†i kho·∫£n**
- **T·∫°o/Import v√≠** t·ª´ Secret Recovery Phrase (SRP) ho·∫∑c private key
- **Qu·∫£n l√Ω nhi·ªÅu t√†i kho·∫£n** trong c√πng m·ªôt v√≠
- **Backup v√† kh√¥i ph·ª•c v√≠** an to√†n
- **Hardware wallet support** (Ledger, Keystone/QR-based wallets)
- **Snap Keyring** ƒë·ªÉ m·ªü r·ªông lo·∫°i t√†i kho·∫£n h·ªó tr·ª£

### **2. Giao d·ªãch & Token**
- **G·ª≠i/nh·∫≠n ETH v√† ERC-20 tokens**
- **Token detection** v√† qu·∫£n l√Ω t·ª± ƒë·ªông
- **NFT support** (ERC-721, ERC-1155)
- **Smart transactions** ƒë·ªÉ t·ªëi ∆∞u gas fees
- **Transaction history** v·ªõi chi ti·∫øt ƒë·∫ßy ƒë·ªß
- **Gas fee estimation** v√† t√πy ch·ªânh

### **3. DeFi & Web3**
- **Token swaps** th√¥ng qua Swaps aggregator
- **Bridge** tokens gi·ªØa c√°c networks
- **Staking** v√† **Earn** features
- **DeFi protocol integration**
- **DApp browser** t√≠ch h·ª£p ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi Web3 apps

### **4. Multi-chain Support**
- **Ethereum mainnet** v√† c√°c testnets
- **Layer 2 solutions** (Arbitrum, Optimism, Polygon, etc.)
- **Custom networks** c√≥ th·ªÉ th√™m th·ªß c√¥ng
- **Network switching** cho t·ª´ng DApp ri√™ng bi·ªát

### **5. B·∫£o m·∫≠t & Privacy**
- **Biometric authentication** (FaceID, TouchID, Fingerprint)
- **App lock** v·ªõi timeout t·ª± ƒë·ªông
- **Phishing protection**
- **Security alerts** t·ª´ PPOM (Personal Protection Object Manager)
- **Transaction simulation** ƒë·ªÉ preview k·∫øt qu·∫£

### **6. WalletConnect & SDK**
- **WalletConnect v1 & v2** support
- **MetaMask SDK** integration
- **Deep linking** support
- **QR code** scanning cho connections

### **7. Portfolio & Analytics**
- **Portfolio tracking** v·ªõi gi√° tr·ªã fiat
- **Token price updates** real-time
- **Historical price data**
- **Analytics integration** (Segment, MetaMetrics)

### **8. Advanced Features**
- **Snaps** - Extension system cho third-party integrations
- **Multi-language support** (23+ languages)
- **Dark/Light theme**
- **Notifications** system
- **Profile sync** across devices

## üèóÔ∏è **Ki·∫øn tr√∫c k·ªπ thu·∫≠t**

### **Core Technologies:**
- **React Native** - Cross-platform mobile development
- **TypeScript** - Type-safe JavaScript
- **Redux** - State management
- **Detox/WDIO** - E2E testing
- **Metro** - JavaScript bundler

### **Blockchain Integration:**
- **@metamask/controllers** - Core blockchain controllers
- **ethers.js/@ethersproject** - Ethereum interaction
- **@metamask/keyring-controller** - Private key management
- **@metamask/transaction-controller** - Transaction handling

### **Key Components:**
- **Engine.ts** - Core blockchain engine qu·∫£n l√Ω t·∫•t c·∫£ controllers
- **Controllers** - Modular architecture cho t·ª´ng ch·ª©c nƒÉng
- **Background Bridge** - Communication v·ªõi DApps
- **RPC Methods** - Ethereum JSON-RPC implementation

## üéØ **M·ª•c ti√™u ng∆∞·ªùi d√πng**

MetaMask Mobile ph·ª•c v·ª• cho:
- **Ng∆∞·ªùi d√πng crypto m·ªõi** v·ªõi UI th√¢n thi·ªán v√† onboarding d·ªÖ d√†ng
- **Trader/Investor** v·ªõi portfolio tracking v√† swaps
- **DeFi users** v·ªõi DApp browser v√† protocol integrations  
- **NFT collectors** v·ªõi full NFT support
- **Developers** v·ªõi SDK v√† extensive customization options

ƒê√¢y l√† m·ªôt ·ª©ng d·ª•ng v√≠ cryptocurrency r·∫•t ho√†n ch·ªânh v√† ti√™n ti·∫øn, ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi ƒë·ªôi ng≈© MetaMask v·ªõi focus m·∫°nh v√†o b·∫£o m·∫≠t, UX v√† kh·∫£ nƒÉng m·ªü r·ªông cho h·ªá sinh th√°i Web3.

---

**User**

h√£y check ph√¢n walletconnect

---

**Cursor**

T√¥i s·∫Ω ki·ªÉm tra ph·∫ßn WalletConnect trong d·ª± √°n MetaMask Mobile ƒë·ªÉ hi·ªÉu c√°ch n√≥ ƒë∆∞·ª£c implement.

T√¥i ƒë√£ ph√¢n t√≠ch chi ti·∫øt ph·∫ßn WalletConnect trong MetaMask Mobile. D∆∞·ªõi ƒë√¢y l√† t√≥m t·∫Øt ƒë·∫ßy ƒë·ªß:

## üîó **WalletConnect Implementation trong MetaMask Mobile**

### **üìã T·ªïng quan Ki·∫øn tr√∫c**

MetaMask Mobile h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß **WalletConnect v1** v√† **WalletConnect v2** v·ªõi ki·∫øn tr√∫c ƒë∆∞·ª£c thi·∫øt k·∫ø r·∫•t chuy√™n nghi·ªáp:

### **üèóÔ∏è Core Components**

#### **1. WalletConnect v1 (`WalletConnect.js`)**
```javascript
class WalletConnect {
  redirectUrl = null;
  autosign = false;
  backgroundBridge = null;
  url = { current: null };
  title = { current: null };
  icon = { current: null };
  dappScheme = { current: null };
  requestsToRedirect = {};
  hostname = null;
  requestOriginatedFrom = null;
}
```

**Ch·ª©c nƒÉng ch√≠nh:**
- **Session Management**: Qu·∫£n l√Ω k·∫øt n·ªëi v√† session v·ªõi DApps
- **Request Handling**: X·ª≠ l√Ω c√°c RPC requests t·ª´ DApps
- **Background Bridge**: T·∫°o c·∫ßu n·ªëi v·ªõi engine ƒë·ªÉ x·ª≠ l√Ω blockchain operations
- **Auto-redirect**: T·ª± ƒë·ªông redirect v·ªÅ DApp sau khi x·ª≠ l√Ω requests

#### **2. WalletConnect v2 (`WalletConnectV2.ts`)**
```typescript
export class WC2Manager {
  private static instance: WC2Manager;
  private navigation?: NavigationContainerRef;
  private web3Wallet: IWalletKit;
  private sessions: { [topic: string]: WalletConnect2Session };
  private deeplinkSessions: {
    [pairingTopic: string]: { redirectUrl?: string; origin: string };
  } = {};
}
```

**C·∫£i ti·∫øn v2:**
- **Singleton Pattern**: Qu·∫£n l√Ω centralized cho t·∫•t c·∫£ sessions
- **Better Session Persistence**: Session ƒë∆∞·ª£c l∆∞u tr·ªØ persistent
- **Enhanced Security**: C·∫£i thi·ªán b·∫£o m·∫≠t v·ªõi relay protocol
- **Multi-chain Support**: H·ªó tr·ª£ multiple chains trong m·ªôt session

#### **3. Session Management (`WalletConnect2Session.ts`)**
```typescript
class WalletConnect2Session {
  private backgroundBridge: BackgroundBridge;
  private web3Wallet: IWalletKit;
  private deeplink: boolean;
  private requestsToRedirect: { [request: string]: boolean } = {};
  private topicByRequestId: { [requestId: string]: string } = {};
  private requestByRequestId: {
    [requestId: string]: WalletKitTypes.SessionRequest;
  } = {};
}
```

### **üîß Ch·ª©c nƒÉng ch√≠nh**

#### **1. Connection Flow**
```javascript
// QR Code ho·∫∑c URI scanning
public async connect({
  wcUri,
  redirectUrl,
  origin,
}: {
  wcUri: string;
  redirectUrl?: string;
  origin: string; // deeplink or qrcode
})
```

**Flow k·∫øt n·ªëi:**
1. **Parse URI**: Ph√¢n t√≠ch WalletConnect URI (v1 ho·∫∑c v2)
2. **Version Detection**: T·ª± ƒë·ªông detect version v√† route appropriately  
3. **Session Proposal**: DApp g·ª≠i session proposal
4. **User Approval**: User approve/reject connection
5. **Session Start**: Establish session v√† l∆∞u persistent

#### **2. Supported RPC Methods**
```typescript
const allEIP155Methods = [
  // Standard methods
  'eth_sendTransaction',
  'eth_sign',
  'eth_signTransaction', 
  'eth_signTypedData',
  'eth_signTypedData_v3',
  'eth_signTypedData_v4',
  'personal_sign',
  'eth_accounts',
  'eth_chainId',
  
  // Wallet methods
  'wallet_addEthereumChain',
  'wallet_switchEthereumChain',
  'wallet_watchAsset',
  'wallet_requestPermissions',
];
```

#### **3. Methods Requiring Redirect**
```typescript
const METHODS_TO_REDIRECT = {
  eth_requestAccounts: true,
  eth_sendTransaction: true,
  eth_signTransaction: true,
  personal_sign: true,
  eth_signTypedData: true,
  eth_signTypedData_v3: true,
  eth_signTypedData_v4: true,
  wallet_watchAsset: true,
  wallet_addEthereumChain: true,
  wallet_switchEthereumChain: true,
};
```

#### **4. Background Bridge Integration**
```javascript
this.backgroundBridge = new BackgroundBridge({
  webview: null,
  url: this.url.current,
  isWalletConnect: true,
  wcWalletConnector: this.walletConnector,
  wcRequestActions: {
    approveRequest: this.approveRequest,
    rejectRequest: this.rejectRequest,
    updateSession: this.updateSession,
  },
  // RPC Middleware cho WalletConnect
  getRpcMethodMiddleware: ({ hostname, getProviderState }) =>
    getRpcMethodMiddleware({
      hostname: WALLET_CONNECT_ORIGIN + this.hostname,
      getProviderState,
      isWalletConnect: true,
    }),
});
```

### **üîê Security Features**

#### **1. Permission Management**
- **Per-origin permissions**: M·ªói DApp c√≥ permissions ri√™ng
- **Chain-specific permissions**: Ki·ªÉm so√°t access theo chain
- **Account filtering**: Ch·ªâ expose authorized accounts

#### **2. Request Validation**
```typescript
// Ki·ªÉm tra permissions tr∆∞·ªõc khi x·ª≠ l√Ω request
const checkWCPermissions = async ({
  origin,
  caip2ChainId,
  allowSwitchingToNewChain = false,
}: { 
  origin: string; 
  caip2ChainId: CaipChainId; 
  allowSwitchingToNewChain?: boolean 
})
```

#### **3. Chain Switching Security**
- **Network validation**: Verify chain ID tr∆∞·ªõc khi switch
- **User confirmation**: Require user approval cho new chains
- **Automatic updates**: Sync account/chain changes v·ªõi sessions

### **üì± UI Components**

#### **1. Session Management Screen**
```javascript
export default class WalletConnectSessions extends PureComponent {
  state = {
    sessions: [],     // v1 sessions
    sessionsV2: [],   // v2 sessions  
  };
}
```

**Features:**
- **Active Sessions List**: Hi·ªÉn th·ªã t·∫•t c·∫£ active connections
- **Session Details**: Show DApp info, URL, connection time
- **Bulk Management**: Kill individual ho·∫∑c all sessions
- **Version Support**: Unified UI cho c·∫£ v1 v√† v2

#### **2. Connection Approval Modal**
- **DApp Metadata Display**: Logo, name, URL, description
- **Permission Preview**: Show requested accounts v√† chains
- **Security Warnings**: Alert v·ªÅ potential risks
- **User Actions**: Approve/Reject v·ªõi clear options

### **‚öôÔ∏è Configuration**

#### **1. Project Setup**
```javascript
const { PROJECT_ID } = AppConstants.WALLET_CONNECT;
export const isWC2Enabled = 
  typeof PROJECT_ID === 'string' && PROJECT_ID?.length > 0;
```

#### **2. Client Options**
```javascript
export const CLIENT_OPTIONS = {
  clientMeta: {
    description: 'MetaMask Mobile app',
    url: 'https://metamask.io',
    icons: [],
    name: 'MetaMask',
    ssl: true,
  },
};
```

### **üîÑ Session Lifecycle**

#### **1. Session Persistence**
```javascript
const persistSessions = async () => {
  const sessions = connectors
    .filter((connector) => connector?.walletConnector?.connected)
    .map((connector) => ({
      ...connector.walletConnector.session,
      autosign: connector.autosign,
      redirectUrl: connector.redirectUrl,
      lastTimeConnected: new Date(),
    }));
  
  await StorageWrapper.setItem(WALLETCONNECT_SESSIONS, JSON.stringify(sessions));
};
```

#### **2. Auto-reconnection**
- **Resume sessions**: T·ª± ƒë·ªông restore sessions khi app restart
- **Health checks**: Monitor session status v√† cleanup expired ones
- **Background sync**: Keep sessions synced v·ªõi latest state

### **üéØ Advanced Features**

#### **1. Deep Linking Support**
```typescript
this.deeplinkSessions[paired.topic] = {
  redirectUrl,
  origin,
};
```

#### **2. Multi-Chain Operations**
- **Chain-aware requests**: Handle requests theo specific chains
- **Cross-chain session management**: Manage sessions across multiple networks
- **CAIP-compliant**: Support CAIP standards cho multi-chain

#### **3. Transaction Handling**
```typescript
private async handleSendTransaction(
  caip2ChainId: CaipChainId,
  requestEvent: WalletKitTypes.SessionRequest,
  methodParams: any,
  origin: string
)
```

### **üìä Monitoring & Analytics**

- **Connection Analytics**: Track connection success rates
- **Usage Metrics**: Monitor which DApps connect most frequently  
- **Error Reporting**: Log v√† report connection failures
- **Performance Monitoring**: Track response times cho requests

### **üöÄ Key Strengths**

1. **Dual Version Support**: Seamless support cho c·∫£ v1 v√† v2
2. **Robust Architecture**: Well-structured v·ªõi clear separation of concerns
3. **Security-First**: Comprehensive permission v√† validation system
4. **User Experience**: Smooth connection flow v·ªõi good UX
5. **Extensibility**: Easy to extend v·ªõi new features
6. **Performance**: Optimized session management v√† background processing

WalletConnect implementation trong MetaMask Mobile l√† m·ªôt trong nh·ªØng implementation t·ªët nh·∫•t trong ecosystem, v·ªõi architecture ho√†n ch·ªânh v√† security features m·∫°nh m·∫Ω.

```javascript
class WalletConnect {
  redirectUrl = null;
  autosign = false;
  backgroundBridge = null;
  url = { current: null };
  title = { current: null };
  icon = { current: null };
  dappScheme = { current: null };
  requestsToRedirect = {};
  hostname = null;
  requestOriginatedFrom = null;
}
```

```typescript
export class WC2Manager {
  private static instance: WC2Manager;
  private navigation?: NavigationContainerRef;
  private web3Wallet: IWalletKit;
  private sessions: { [topic: string]: WalletConnect2Session };
  private deeplinkSessions: {
    [pairingTopic: string]: { redirectUrl?: string; origin: string };
  } = {};
}
```

```typescript
class WalletConnect2Session {
  private backgroundBridge: BackgroundBridge;
  private web3Wallet: IWalletKit;
  private deeplink: boolean;
  private requestsToRedirect: { [request: string]: boolean } = {};
  private topicByRequestId: { [requestId: string]: string } = {};
  private requestByRequestId: {
    [requestId: string]: WalletKitTypes.SessionRequest;
  } = {};
}
```

```javascript
// QR Code ho·∫∑c URI scanning
public async connect({
  wcUri,
  redirectUrl,
  origin,
}: {
  wcUri: string;
  redirectUrl?: string;
  origin: string; // deeplink or qrcode
})
```

```typescript
const allEIP155Methods = [
  // Standard methods
  'eth_sendTransaction',
  'eth_sign',
  'eth_signTransaction', 
  'eth_signTypedData',
  'eth_signTypedData_v3',
  'eth_signTypedData_v4',
  'personal_sign',
  'eth_accounts',
  'eth_chainId',
  
  // Wallet methods
  'wallet_addEthereumChain',
  'wallet_switchEthereumChain',
  'wallet_watchAsset',
  'wallet_requestPermissions',
];
```

```typescript
const METHODS_TO_REDIRECT = {
  eth_requestAccounts: true,
  eth_sendTransaction: true,
  eth_signTransaction: true,
  personal_sign: true,
  eth_signTypedData: true,
  eth_signTypedData_v3: true,
  eth_signTypedData_v4: true,
  wallet_watchAsset: true,
  wallet_addEthereumChain: true,
  wallet_switchEthereumChain: true,
};
```

```javascript
this.backgroundBridge = new BackgroundBridge({
  webview: null,
  url: this.url.current,
  isWalletConnect: true,
  wcWalletConnector: this.walletConnector,
  wcRequestActions: {
    approveRequest: this.approveRequest,
    rejectRequest: this.rejectRequest,
    updateSession: this.updateSession,
  },
  // RPC Middleware cho WalletConnect
  getRpcMethodMiddleware: ({ hostname, getProviderState }) =>
    getRpcMethodMiddleware({
      hostname: WALLET_CONNECT_ORIGIN + this.hostname,
      getProviderState,
      isWalletConnect: true,
    }),
});
```

```typescript
// Ki·ªÉm tra permissions tr∆∞·ªõc khi x·ª≠ l√Ω request
const checkWCPermissions = async ({
  origin,
  caip2ChainId,
  allowSwitchingToNewChain = false,
}: { 
  origin: string; 
  caip2ChainId: CaipChainId; 
  allowSwitchingToNewChain?: boolean 
})
```

```javascript
export default class WalletConnectSessions extends PureComponent {
  state = {
    sessions: [],     // v1 sessions
    sessionsV2: [],   // v2 sessions  
  };
}
```

```javascript
const { PROJECT_ID } = AppConstants.WALLET_CONNECT;
export const isWC2Enabled = 
  typeof PROJECT_ID === 'string' && PROJECT_ID?.length > 0;
```

```javascript
export const CLIENT_OPTIONS = {
  clientMeta: {
    description: 'MetaMask Mobile app',
    url: 'https://metamask.io',
    icons: [],
    name: 'MetaMask',
    ssl: true,
  },
};
```

```javascript
const persistSessions = async () => {
  const sessions = connectors
    .filter((connector) => connector?.walletConnector?.connected)
    .map((connector) => ({
      ...connector.walletConnector.session,
      autosign: connector.autosign,
      redirectUrl: connector.redirectUrl,
      lastTimeConnected: new Date(),
    }));
  
  await StorageWrapper.setItem(WALLETCONNECT_SESSIONS, JSON.stringify(sessions));
};
```

```typescript
this.deeplinkSessions[paired.topic] = {
  redirectUrl,
  origin,
};
```

```typescript
private async handleSendTransaction(
  caip2ChainId: CaipChainId,
  requestEvent: WalletKitTypes.SessionRequest,
  methodParams: any,
  origin: string
)
```

---

**User**

c√°ch handle deeplink v√† redirect v·ªÅ l·∫°i dapp

---

**Cursor**

T√¥i s·∫Ω ph√¢n t√≠ch c√°ch MetaMask Mobile handle deeplink v√† redirect v·ªÅ l·∫°i DApp. H√£y t√¨m hi·ªÉu c√°c component li√™n quan ƒë·∫øn deeplink v√† redirect mechanism.

D·ª±a tr√™n ph√¢n t√≠ch codebase, ƒë√¢y l√† c√°ch **MetaMask Mobile handle deeplink v√† redirect v·ªÅ l·∫°i DApp**:

## üîó **Deeplink & Redirect Mechanism Overview**

### **üì± Ki·∫øn tr√∫c t·ªïng quan**

```
DApp ‚Üí Deeplink/URI ‚Üí MetaMask ‚Üí Processing ‚Üí Redirect back to DApp
```

## **üöÄ 1. Deeplink Entry Points**

### **A. Supported Protocols**
```typescript
const PROTOCOLS = {
  HTTP: 'http',
  HTTPS: 'https',
  WC: 'wc',           // WalletConnect
  ETHEREUM: 'ethereum',
  DAPP: 'dapp',
  METAMASK: 'metamask',
};
```

### **B. Deeplink Sources**
```typescript
const DEEPLINKS = {
  ORIGIN_DEEPLINK: 'deeplink',        // App-to-app deeplink
  ORIGIN_QR_CODE: 'qr-code',          // QR code scanning
  ORIGIN_NOTIFICATION: 'notifications', // Push notifications
};
```

## **üîÑ 2. Processing Flow**

### **A. DeeplinkManager Parsing**
```typescript
// app/core/DeeplinkManager/ParseManager/parseDeeplink.ts
async function parseDeeplink({
  deeplinkManager: instance,
  url,
  origin,
  browserCallBack,
  onHandled,
}) {
  const { urlObj, params } = extractURLParams(url);
  
  switch (urlObj.protocol.replace(':', '')) {
    case PROTOCOLS.WC:
      connectWithWC({ handled, wcURL, origin, params });
      break;
    case PROTOCOLS.ETHEREUM:
      instance._handleEthereumUrl(url, origin);
      break;
    case PROTOCOLS.METAMASK:
      handleMetaMaskDeeplink({ instance, handled, wcURL, origin, params, url });
      break;
  }
}
```

### **B. WalletConnect Specific Processing**
```typescript
// WalletConnect URI parsing v√† connection
export function connectWithWC({
  handled,
  wcURL,
  origin,
  params,
}) {
  handled();
  
  WC2Manager.getInstance()
    .then((instance) =>
      instance.connect({
        wcUri: wcURL,
        origin,
        redirectUrl: params?.redirect,  // DApp's redirect URL
      }),
    );
}
```

## **‚¨ÖÔ∏è 3. Redirect Mechanisms**

### **A. WalletConnect v1 Redirect**
```javascript
// app/core/WalletConnect/WalletConnect.js
class WalletConnect {
  redirect = () => {
    // Skip redirect if originated from QR code
    if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE)
      return;

    setTimeout(() => {
      if (this.dappScheme.current || this.redirectUrl) {
        // Use DApp's custom scheme or redirect URL
        Linking.openURL(
          this.dappScheme.current
            ? `${this.dappScheme.current}://`
            : this.redirectUrl,
        );
      } else {
        // Fallback: minimize app to show previous app
        Minimizer.goBack();
      }
    }, 300);
  };
}
```

### **B. WalletConnect v2 Enhanced Redirect**
```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
redirect = (context?: string) => {
  if (!this.deeplink) return;  // Only redirect for deeplink connections

  const showReturnModal = () => {
    navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
      screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
    });
  };

  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ - Try to use DApp's redirect link
      const redirect = this.session.peer.metadata.redirect;
      const peerLink = redirect?.native || redirect?.universal;
      
      if (peerLink) {
        Linking.openURL(peerLink).catch((error) => {
          // Fallback to return modal if redirect fails
          showReturnModal();
        });
      } else {
        showReturnModal();
      }
    } else {
      // Older iOS versions or Android - use system minimize
      Minimizer.goBack();
    }
  }, 100);
};
```

### **C. SDK Deeplink Protocol Redirect**
```typescript
// app/core/SDKConnect/SDKDeeplinkProtocol/DeeplinkProtocolService.ts
public async openDeeplink({
  message,
  dappScheme,
  clientId,
}: {
  message: unknown;
  dappScheme: string;
  clientId: string;
}) {
  const base64Message = btoa(JSON.stringify(message));
  const deeplink = `${dappScheme}://mmsdk?message=${base64Message}`;
  
  await Linking.openURL(deeplink);
}
```

## **üéØ 4. Redirect Triggers**

### **A. Methods Requiring Redirect**
```typescript
const METHODS_TO_REDIRECT = {
  eth_requestAccounts: true,
  eth_sendTransaction: true,
  eth_signTransaction: true,
  personal_sign: true,
  eth_signTypedData: true,
  eth_signTypedData_v3: true,
  eth_signTypedData_v4: true,
  wallet_watchAsset: true,
  wallet_addEthereumChain: true,
  wallet_switchEthereumChain: true,
};
```

### **B. Conditional Redirect Logic**
```typescript
needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    delete this.requestsToRedirect[id];
    this.redirect(`needsRedirect_${id}`);
  }
};

// Called after approve/reject
approveRequest = ({ id, result }) => {
  this.walletConnector.approveRequest({ id, result });
  this.needsRedirect(id);  // Trigger redirect if needed
};

rejectRequest = ({ id, error }) => {
  this.walletConnector.rejectRequest({ id, error });
  this.needsRedirect(id);  // Trigger redirect if needed
};
```

## **üì± 5. Return to DApp Modal**

### **A. Modal Component**
```tsx
// app/components/Views/ReturnToAppModal/ReturnToAppModal.tsx
const ReturnToAppModal = () => {
  return (
    <BottomSheet>
      <SheetHeader title={strings('sdk_return_to_app_modal.title')} />
      <Text style={styles.description}>
        {strings('sdk_return_to_app_modal.description')}
      </Text>
    </BottomSheet>
  );
};
```

### **B. When Return Modal is Shown**
- **iOS 17+**: When direct app redirect fails
- **Universal links kh√¥ng available**: Fallback option
- **User choice**: Allow user to manually return to DApp

## **‚öôÔ∏è 6. Platform-Specific Behaviors**

### **A. iOS Behaviors**
```typescript
if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
  // iOS 17+ uses direct app redirection
  const peerLink = redirect?.native || redirect?.universal;
  if (peerLink) {
    Linking.openURL(peerLink);
  } else {
    showReturnModal();
  }
} else {
  // Older iOS - use system minimize
  Minimizer.goBack();
}
```

### **B. Android Behaviors**
```typescript
// Android primarily uses Minimizer.goBack()
// This minimizes MetaMask and shows the previous app
Minimizer.goBack();
```

## **üîÑ 7. SDK Connection Redirect Flow**

### **A. SDK Message Handling**
```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
const canRedirect = connection.rpcQueueManager.canRedirect({ method });

if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  // Skip redirect for QR code connections
  return;
}

if (!canRedirect) {
  // Skip redirect for certain methods
  return;
}

if (connection.trigger !== 'deeplink') {
  // Only redirect for deeplink-originated connections
  return;
}

// Show return to DApp modal
connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
  screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
});
```

### **B. Batch RPC Handling**
```typescript
// Only redirect after ALL requests in batch are completed
const isLastRpcOrError = await handleBatchRpcResponse({
  chainRpcs: chainRPCs,
  msg,
  batchRPCManager: connection.batchRPCManager,
});

if (!isLastRpcOrError) {
  // Don't redirect until batch is complete
  return;
}
```

## **üõ°Ô∏è 8. Security & Edge Cases**

### **A. QR Code Exception**
```typescript
// Never auto-redirect for QR code scanned connections
if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE)
  return;
```

### **B. Pending Requests Check**
```typescript
// Don't redirect if there are pending sign requests
const requests = this.web3Wallet.getPendingSessionRequests() || [];
const hasPendingSignRequest = 
  requests[0]?.params?.request?.method === 'personal_sign';

if (!hasPendingSignRequest) {
  this.needsRedirect(id);
}
```

### **C. Connection Validation**
```typescript
// Validate deeplink before processing
const validatedUrl = new URL(url);
const isValidWCURI = parseWalletConnectUri(uri);
```

## **üìä 9. Analytics & Monitoring**

### **A. Redirect Analytics**
```typescript
if (isAnalyticsTrackedRpcMethod(method)) {
  if (msg?.data?.error) {
    analytics.track('wallet_action_user_rejected', { anon_id: anonId });
  } else {
    analytics.track('wallet_action_user_approved', { anon_id: anonId });
  }
}
```

### **B. Error Handling**
```typescript
Linking.openURL(deeplink).catch((error) => {
  DevLogger.log(`Error opening deeplink: ${error}`);
  showReturnModal();  // Fallback to manual return
});
```

## **üéØ Key Features**

1. **Multi-Protocol Support**: HTTP(S), WalletConnect, Ethereum, MetaMask schemes
2. **Platform Optimization**: Different strategies cho iOS vs Android
3. **Graceful Degradation**: Fallback mechanisms khi direct redirect fails
4. **User Choice**: Return modal as backup option
5. **Security First**: Validation v√† proper origin tracking
6. **Batch Handling**: Smart redirect timing cho multiple requests
7. **Session Persistence**: Deeplink session tracking across app lifecycle

Mechanism n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø r·∫•t sophisticated ƒë·ªÉ handle t·∫•t c·∫£ edge cases v√† provide smooth UX cho users khi interact v·ªõi DApps qua WalletConnect ho·∫∑c deeplinks.

```plaintext
DApp ‚Üí Deeplink/URI ‚Üí MetaMask ‚Üí Processing ‚Üí Redirect back to DApp
```

```typescript
const PROTOCOLS = {
  HTTP: 'http',
  HTTPS: 'https',
  WC: 'wc',           // WalletConnect
  ETHEREUM: 'ethereum',
  DAPP: 'dapp',
  METAMASK: 'metamask',
};
```

```typescript
const DEEPLINKS = {
  ORIGIN_DEEPLINK: 'deeplink',        // App-to-app deeplink
  ORIGIN_QR_CODE: 'qr-code',          // QR code scanning
  ORIGIN_NOTIFICATION: 'notifications', // Push notifications
};
```

```typescript
// app/core/DeeplinkManager/ParseManager/parseDeeplink.ts
async function parseDeeplink({
  deeplinkManager: instance,
  url,
  origin,
  browserCallBack,
  onHandled,
}) {
  const { urlObj, params } = extractURLParams(url);
  
  switch (urlObj.protocol.replace(':', '')) {
    case PROTOCOLS.WC:
      connectWithWC({ handled, wcURL, origin, params });
      break;
    case PROTOCOLS.ETHEREUM:
      instance._handleEthereumUrl(url, origin);
      break;
    case PROTOCOLS.METAMASK:
      handleMetaMaskDeeplink({ instance, handled, wcURL, origin, params, url });
      break;
  }
}
```

```typescript
// WalletConnect URI parsing v√† connection
export function connectWithWC({
  handled,
  wcURL,
  origin,
  params,
}) {
  handled();
  
  WC2Manager.getInstance()
    .then((instance) =>
      instance.connect({
        wcUri: wcURL,
        origin,
        redirectUrl: params?.redirect,  // DApp's redirect URL
      }),
    );
}
```

```javascript
// app/core/WalletConnect/WalletConnect.js
class WalletConnect {
  redirect = () => {
    // Skip redirect if originated from QR code
    if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE)
      return;

    setTimeout(() => {
      if (this.dappScheme.current || this.redirectUrl) {
        // Use DApp's custom scheme or redirect URL
        Linking.openURL(
          this.dappScheme.current
            ? `${this.dappScheme.current}://`
            : this.redirectUrl,
        );
      } else {
        // Fallback: minimize app to show previous app
        Minimizer.goBack();
      }
    }, 300);
  };
}
```

```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
redirect = (context?: string) => {
  if (!this.deeplink) return;  // Only redirect for deeplink connections

  const showReturnModal = () => {
    navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
      screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
    });
  };

  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ - Try to use DApp's redirect link
      const redirect = this.session.peer.metadata.redirect;
      const peerLink = redirect?.native || redirect?.universal;
      
      if (peerLink) {
        Linking.openURL(peerLink).catch((error) => {
          // Fallback to return modal if redirect fails
          showReturnModal();
        });
      } else {
        showReturnModal();
      }
    } else {
      // Older iOS versions or Android - use system minimize
      Minimizer.goBack();
    }
  }, 100);
};
```

```typescript
// app/core/SDKConnect/SDKDeeplinkProtocol/DeeplinkProtocolService.ts
public async openDeeplink({
  message,
  dappScheme,
  clientId,
}: {
  message: unknown;
  dappScheme: string;
  clientId: string;
}) {
  const base64Message = btoa(JSON.stringify(message));
  const deeplink = `${dappScheme}://mmsdk?message=${base64Message}`;
  
  await Linking.openURL(deeplink);
}
```

```typescript
const METHODS_TO_REDIRECT = {
  eth_requestAccounts: true,
  eth_sendTransaction: true,
  eth_signTransaction: true,
  personal_sign: true,
  eth_signTypedData: true,
  eth_signTypedData_v3: true,
  eth_signTypedData_v4: true,
  wallet_watchAsset: true,
  wallet_addEthereumChain: true,
  wallet_switchEthereumChain: true,
};
```

```typescript
needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    delete this.requestsToRedirect[id];
    this.redirect(`needsRedirect_${id}`);
  }
};

// Called after approve/reject
approveRequest = ({ id, result }) => {
  this.walletConnector.approveRequest({ id, result });
  this.needsRedirect(id);  // Trigger redirect if needed
};

rejectRequest = ({ id, error }) => {
  this.walletConnector.rejectRequest({ id, error });
  this.needsRedirect(id);  // Trigger redirect if needed
};
```

```typescriptreact
// app/components/Views/ReturnToAppModal/ReturnToAppModal.tsx
const ReturnToAppModal = () => {
  return (
    <BottomSheet>
      <SheetHeader title={strings('sdk_return_to_app_modal.title')} />
      <Text style={styles.description}>
        {strings('sdk_return_to_app_modal.description')}
      </Text>
    </BottomSheet>
  );
};
```

```typescript
if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
  // iOS 17+ uses direct app redirection
  const peerLink = redirect?.native || redirect?.universal;
  if (peerLink) {
    Linking.openURL(peerLink);
  } else {
    showReturnModal();
  }
} else {
  // Older iOS - use system minimize
  Minimizer.goBack();
}
```

```typescript
// Android primarily uses Minimizer.goBack()
// This minimizes MetaMask and shows the previous app
Minimizer.goBack();
```

```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
const canRedirect = connection.rpcQueueManager.canRedirect({ method });

if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  // Skip redirect for QR code connections
  return;
}

if (!canRedirect) {
  // Skip redirect for certain methods
  return;
}

if (connection.trigger !== 'deeplink') {
  // Only redirect for deeplink-originated connections
  return;
}

// Show return to DApp modal
connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
  screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
});
```

```typescript
// Only redirect after ALL requests in batch are completed
const isLastRpcOrError = await handleBatchRpcResponse({
  chainRpcs: chainRPCs,
  msg,
  batchRPCManager: connection.batchRPCManager,
});

if (!isLastRpcOrError) {
  // Don't redirect until batch is complete
  return;
}
```

```typescript
// Never auto-redirect for QR code scanned connections
if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE)
  return;
```

```typescript
// Don't redirect if there are pending sign requests
const requests = this.web3Wallet.getPendingSessionRequests() || [];
const hasPendingSignRequest = 
  requests[0]?.params?.request?.method === 'personal_sign';

if (!hasPendingSignRequest) {
  this.needsRedirect(id);
}
```

```typescript
// Validate deeplink before processing
const validatedUrl = new URL(url);
const isValidWCURI = parseWalletConnectUri(uri);
```

```typescript
if (isAnalyticsTrackedRpcMethod(method)) {
  if (msg?.data?.error) {
    analytics.track('wallet_action_user_rejected', { anon_id: anonId });
  } else {
    analytics.track('wallet_action_user_approved', { anon_id: anonId });
  }
}
```

```typescript
Linking.openURL(deeplink).catch((error) => {
  DevLogger.log(`Error opening deeplink: ${error}`);
  showReturnModal();  // Fallback to manual return
});
```

---

**User**

t√¥i th·∫•y sau khi handleConnect v√† show toastRef?.current?.showToast th√¨ app t·ª± tr·ªü l·∫°i browser dapp

---

**Cursor**

```typescript
await Engine.context.PermissionController.acceptPermissionsRequest(request);
// ... tracking events
toastRef?.current?.showToast({
  variant: ToastVariants.Network,
  labelOptions,
  networkImageSource: faviconSource,
  hasNoTimeout: false,
});
```

ƒê√∫ng r·ªìi! Sau khi `handleConnect` th√†nh c√¥ng v√† hi·ªÉn th·ªã toast, app s·∫Ω t·ª± ƒë·ªông redirect v·ªÅ DApp. ƒê√¢y l√† c∆° ch·∫ø ho·∫°t ƒë·ªông:

## üîÑ **Flow Redirect sau khi Connect**

### **1. Trigger Point trong AccountConnect**
```typescript
// app/components/Views/AccountConnect/AccountConnect.tsx
const handleConnect = useCallback(async () => {
  try {
    setIsLoading(true);
    
    // ‚úÖ Accept permission request - TRIGGER POINT
    await Engine.context.PermissionController.acceptPermissionsRequest(request);
    
    // Show toast
    toastRef?.current?.showToast({
      variant: ToastVariants.Network,
      labelOptions,
      networkImageSource: faviconSource,
      hasNoTimeout: false,
    });
    
    // üöÄ Redirect s·∫Ω x·∫£y ra ngay sau ƒë√¢y
  } catch (e) {
    // handle error
  } finally {
    setIsLoading(false);
  }
}, [/* dependencies */]);
```

## **üéØ 2. Permission Acceptance Chain Reaction**

### **A. PermissionController.acceptPermissionsRequest()**
```typescript
// Khi g·ªçi acceptPermissionsRequest, n√≥ s·∫Ω:
// 1. Update permissions trong state
// 2. Resolve pending permission request
// 3. Trigger registered listeners/callbacks
// 4. Notify connected services (SDK/WalletConnect)
```

### **B. SDK Connection Response**
```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
export const handleSendMessage = async ({ msg, connection }) => {
  // After processing response
  const canRedirect = connection.rpcQueueManager.canRedirect({ method });
  
  if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
    return; // Skip redirect for QR connections
  }
  
  if (!canRedirect) {
    return; // Skip for certain methods
  }
  
  if (connection.trigger !== 'deeplink') {
    return; // Only redirect for deeplink connections
  }
  
  // üöÄ REDIRECT HAPPENS HERE
  connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
    screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
  });
};
```

### **C. WalletConnect Session Response**
```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
approveRequest = async ({ id, result }) => {
  // Send approval response
  await this.web3Wallet.respondSessionRequest({
    topic,
    response: { id: parseInt(id), jsonrpc: '2.0', result },
  });
  
  this._isHandlingRequest = false;
  
  // Check for pending requests
  const requests = this.web3Wallet.getPendingSessionRequests() || [];
  const hasPendingSignRequest = 
    requests[0]?.params?.request?.method === 'personal_sign';
  
  if (!hasPendingSignRequest) {
    this.needsRedirect(id); // üöÄ REDIRECT TRIGGER
  }
};

needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    delete this.requestsToRedirect[id];
    this.redirect(`needsRedirect_${id}`); // üöÄ ACTUAL REDIRECT
  }
};
```

## **üîÑ 3. Redirect Implementation Details**

### **A. WalletConnect v2 Redirect Logic**
```typescript
redirect = (context?: string) => {
  if (!this.deeplink) return; // Only for deeplink connections
  
  const showReturnModal = () => {
    navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
      screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
    });
  };
  
  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ - Direct app redirect
      const redirect = this.session.peer.metadata.redirect;
      const peerLink = redirect?.native || redirect?.universal;
      
      if (peerLink) {
        Linking.openURL(peerLink).catch(() => showReturnModal());
      } else {
        showReturnModal();
      }
    } else {
      // Older iOS/Android - System minimize
      Minimizer.goBack(); // üöÄ APP MINIMIZES, SHOWING DAPP
    }
  }, 100);
};
```

### **B. SDK Deeplink Protocol**
```typescript
// app/core/SDKConnect/SDKDeeplinkProtocol/DeeplinkProtocolService.ts
public async openDeeplink({ message, dappScheme, clientId }) {
  const base64Message = btoa(JSON.stringify(message));
  const deeplink = `${dappScheme}://mmsdk?message=${base64Message}`;
  
  await Linking.openURL(deeplink); // üöÄ OPEN DAPP WITH RESPONSE
}
```

## **‚è∞ 4. Timing Sequence**

```
1. User clicks "Connect" in AccountConnect
   ‚Üì
2. handleConnect() executes
   ‚Üì
3. acceptPermissionsRequest() called
   ‚Üì
4. Permission request resolved
   ‚Üì
5. Toast displayed to user
   ‚Üì
6. Connected services (SDK/WC) notified
   ‚Üì
7. Response sent back to DApp
   ‚Üì
8. Redirect mechanism triggered:
   - iOS 17+: Direct app redirect via Linking.openURL()
   - Older: Minimizer.goBack() ‚Üí shows previous app
   - Fallback: Return to DApp modal
```

## **üéõÔ∏è 5. Control Factors**

### **A. Connection Type**
```typescript
// Different redirect behavior based on origin:
if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // No redirect for QR scanned connections
}

if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // Skip redirect
}
```

### **B. Platform Differences**
```typescript
// iOS 17+: Direct app switching
if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
  Linking.openURL(peerLink);
} else {
  // Older versions: System minimize
  Minimizer.goBack();
}
```

### **C. Pending Requests Check**
```typescript
// Don't redirect if there are more pending requests
const hasPendingSignRequest = 
  requests[0]?.params?.request?.method === 'personal_sign';

if (!hasPendingSignRequest) {
  this.needsRedirect(id); // Only redirect when all done
}
```

## **üöÄ 6. T√≥m t·∫Øt**

**T·∫°i sao app t·ª± tr·ªü l·∫°i DApp sau khi connect:**

1. **Permission Acceptance**: `acceptPermissionsRequest()` resolves connection
2. **Response Notification**: Connected services ƒë∆∞·ª£c notify
3. **Auto-redirect Mechanism**: Built-in redirect logic ƒë∆∞·ª£c trigger
4. **Platform-specific Behavior**: 
   - **iOS 17+**: Direct app switch via deep linking
   - **Older**: System minimize showing previous app
   - **Fallback**: Return to DApp modal

**ƒê√¢y l√† intended behavior** ƒë·ªÉ t·∫°o seamless UX - user connect trong MetaMask, sau ƒë√≥ t·ª± ƒë·ªông tr·ªü l·∫°i DApp ƒë·ªÉ ti·∫øp t·ª•c workflow m√† kh√¥ng c·∫ßn manual switching.

**Disable redirect**: N·∫øu mu·ªën prevent auto-redirect, c·∫ßn modify logic trong c√°c redirect methods ho·∫∑c connection handling code.

```typescript
// app/components/Views/AccountConnect/AccountConnect.tsx
const handleConnect = useCallback(async () => {
  try {
    setIsLoading(true);
    
    // ‚úÖ Accept permission request - TRIGGER POINT
    await Engine.context.PermissionController.acceptPermissionsRequest(request);
    
    // Show toast
    toastRef?.current?.showToast({
      variant: ToastVariants.Network,
      labelOptions,
      networkImageSource: faviconSource,
      hasNoTimeout: false,
    });
    
    // üöÄ Redirect s·∫Ω x·∫£y ra ngay sau ƒë√¢y
  } catch (e) {
    // handle error
  } finally {
    setIsLoading(false);
  }
}, [/* dependencies */]);
```

```typescript
// Khi g·ªçi acceptPermissionsRequest, n√≥ s·∫Ω:
// 1. Update permissions trong state
// 2. Resolve pending permission request
// 3. Trigger registered listeners/callbacks
// 4. Notify connected services (SDK/WalletConnect)
```

```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
export const handleSendMessage = async ({ msg, connection }) => {
  // After processing response
  const canRedirect = connection.rpcQueueManager.canRedirect({ method });
  
  if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
    return; // Skip redirect for QR connections
  }
  
  if (!canRedirect) {
    return; // Skip for certain methods
  }
  
  if (connection.trigger !== 'deeplink') {
    return; // Only redirect for deeplink connections
  }
  
  // üöÄ REDIRECT HAPPENS HERE
  connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
    screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
  });
};
```

```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
approveRequest = async ({ id, result }) => {
  // Send approval response
  await this.web3Wallet.respondSessionRequest({
    topic,
    response: { id: parseInt(id), jsonrpc: '2.0', result },
  });
  
  this._isHandlingRequest = false;
  
  // Check for pending requests
  const requests = this.web3Wallet.getPendingSessionRequests() || [];
  const hasPendingSignRequest = 
    requests[0]?.params?.request?.method === 'personal_sign';
  
  if (!hasPendingSignRequest) {
    this.needsRedirect(id); // üöÄ REDIRECT TRIGGER
  }
};

needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    delete this.requestsToRedirect[id];
    this.redirect(`needsRedirect_${id}`); // üöÄ ACTUAL REDIRECT
  }
};
```

```typescript
redirect = (context?: string) => {
  if (!this.deeplink) return; // Only for deeplink connections
  
  const showReturnModal = () => {
    navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
      screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
    });
  };
  
  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ - Direct app redirect
      const redirect = this.session.peer.metadata.redirect;
      const peerLink = redirect?.native || redirect?.universal;
      
      if (peerLink) {
        Linking.openURL(peerLink).catch(() => showReturnModal());
      } else {
        showReturnModal();
      }
    } else {
      // Older iOS/Android - System minimize
      Minimizer.goBack(); // üöÄ APP MINIMIZES, SHOWING DAPP
    }
  }, 100);
};
```

```typescript
// app/core/SDKConnect/SDKDeeplinkProtocol/DeeplinkProtocolService.ts
public async openDeeplink({ message, dappScheme, clientId }) {
  const base64Message = btoa(JSON.stringify(message));
  const deeplink = `${dappScheme}://mmsdk?message=${base64Message}`;
  
  await Linking.openURL(deeplink); // üöÄ OPEN DAPP WITH RESPONSE
}
```

```plaintext
1. User clicks "Connect" in AccountConnect
   ‚Üì
2. handleConnect() executes
   ‚Üì
3. acceptPermissionsRequest() called
   ‚Üì
4. Permission request resolved
   ‚Üì
5. Toast displayed to user
   ‚Üì
6. Connected services (SDK/WC) notified
   ‚Üì
7. Response sent back to DApp
   ‚Üì
8. Redirect mechanism triggered:
   - iOS 17+: Direct app redirect via Linking.openURL()
   - Older: Minimizer.goBack() ‚Üí shows previous app
   - Fallback: Return to DApp modal
```

```typescript
// Different redirect behavior based on origin:
if (connection.origin === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // No redirect for QR scanned connections
}

if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // Skip redirect
}
```

```typescript
// iOS 17+: Direct app switching
if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
  Linking.openURL(peerLink);
} else {
  // Older versions: System minimize
  Minimizer.goBack();
}
```

```typescript
// Don't redirect if there are more pending requests
const hasPendingSignRequest = 
  requests[0]?.params?.request?.method === 'personal_sign';

if (!hasPendingSignRequest) {
  this.needsRedirect(id); // Only redirect when all done
}
```

---

**User**

cho t√¥i th·∫•y c√°ch ho·∫°t ƒë·ªông v√† c√°ch t·∫°o Minimizer

---

**Cursor**

T√¥i s·∫Ω t√¨m hi·ªÉu c√°ch ho·∫°t ƒë·ªông v√† implementation c·ªßa Minimizer module trong MetaMask Mobile.

D·ª±a tr√™n ph√¢n t√≠ch source code, ƒë√¢y l√† c√°ch ho·∫°t ƒë·ªông v√† c√°ch t·∫°o **Minimizer** trong MetaMask Mobile:

## üîß **Minimizer Overview**

**Minimizer** l√† m·ªôt **React Native Native Module** ƒë∆∞·ª£c t·∫°o ƒë·ªÉ cho ph√©p app **minimize/move to background** v√† hi·ªÉn th·ªã app tr∆∞·ªõc ƒë√≥ trong task stack (th∆∞·ªùng l√† DApp). 

## üèóÔ∏è **Architecture & Implementation**

### **üì± 1. JavaScript Interface Layer**

```typescript
// app/core/NativeModules.ts
import { NativeModules } from 'react-native';

// Minimizer module allows the app to be pushed to the background
const { Minimizer } = NativeModules;

export { Minimizer };
```

**Usage trong code:**
```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
import { Minimizer } from '../NativeModules';

redirect = (context?: string) => {
  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ specific logic
    } else {
      Minimizer.goBack(); // üöÄ MINIMIZE APP
    }
  }, 100);
};
```

### **ü§ñ 2. Android Implementation**

#### **A. Native Module Class**
```java
// android/app/src/main/java/io/metamask/nativeModules/RCTMinimizer.java
package io.metamask.nativeModules;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;

public class RCTMinimizer extends ReactContextBaseJavaModule {
  private ReactApplicationContext reactContext;
  
  RCTMinimizer(ReactApplicationContext context) {
    super(context);
    this.reactContext = context;
  }

  @Override
  public String getName() {
    return "Minimizer"; // üìå T√™n module accessible t·ª´ JS
  }

  @ReactMethod
  public void goBack() {
    android.app.Activity activity = getCurrentActivity();
    if (activity != null) {
      activity.moveTaskToBack(true); // üöÄ MOVE TO BACKGROUND
    }
  }
}
```

#### **B. Package Registration**
```java
// android/app/src/main/java/io/metamask/nativeModules/RCTMinimizerPackage.java
public class RCTMinimizerPackage implements ReactPackage {
  @Override
  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
    List<NativeModule> modules = new ArrayList<>();
    modules.add(new RCTMinimizer(reactContext)); // üìå Register module
    return modules;
  }
}
```

#### **C. App Integration**
```kotlin
// android/app/src/main/java/io/metamask/MainApplication.kt
import io.metamask.nativeModules.RCTMinimizerPackage

class MainApplication : Application(), ReactApplication {
  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
    this,
    object : DefaultReactNativeHost(this) {
      override fun getPackages(): List<ReactPackage> {
        val packages = PackageList(this).packages.toMutableList()
        packages.add(RCTMinimizerPackage()) // üöÄ ADD MINIMIZER PACKAGE
        return packages
      }
    }
  )
}
```

### **üçé 3. iOS Implementation**

#### **A. Header Declaration**
```objc
// ios/MetaMask/NativeModules/RCTMinimizer/RCTMinimizer.h
#import <React/RCTBridgeModule.h>

@interface RCTMinimizer : NSObject <RCTBridgeModule>
@end
```

#### **B. Implementation**
```objc
// ios/MetaMask/NativeModules/RCTMinimizer/RCTMinimizer.m
#import "RCTMinimizer.h"
#import <UIKit/UIKit.h>
#import <objc/runtime.h>

@interface UISystemNavigationAction : NSObject
@property(nonatomic, readonly, nonnull) NSArray<NSNumber*>* destinations;
-(BOOL)sendResponseForDestination:(NSUInteger)destination;
@end

@implementation RCTMinimizer

RCT_EXPORT_METHOD(goBack)
{
  // üöÄ ACCESS PRIVATE iOS API ƒë·ªÉ minimize app
  Ivar sysNavIvar = class_getInstanceVariable(UIApplication.class, "_systemNavigationAction");
  UIApplication* app = UIApplication.sharedApplication;
  UISystemNavigationAction* action = object_getIvar(app, sysNavIvar);
  
  if (!action) {
      return;
  }
  
  NSUInteger destination = action.destinations.firstObject.unsignedIntegerValue;
  [action sendResponseForDestination:destination]; // üöÄ NAVIGATE BACK
}

RCT_EXPORT_MODULE(); // üìå Register v·ªõi React Native bridge

@end
```

## ‚öôÔ∏è **4. How It Works**

### **A. Android Mechanism**
```java
activity.moveTaskToBack(true);
```

**C√°ch ho·∫°t ƒë·ªông:**
- `moveTaskToBack(true)` moves current task (MetaMask) to background
- **`true` parameter**: Means non-root activities are also moved to back
- **Result**: Previous app in task stack (DApp) becomes visible
- **System behavior**: Android task switcher shows previous app

### **B. iOS Mechanism** 
```objc
// Access private UISystemNavigationAction
UISystemNavigationAction* action = object_getIvar(app, sysNavIvar);
[action sendResponseForDestination:destination];
```

**C√°ch ho·∫°t ƒë·ªông:**
- **Private API Access**: Uses runtime introspection ƒë·ªÉ access private iOS APIs
- **UISystemNavigationAction**: Handles system-level navigation
- **sendResponseForDestination**: Simulates system back navigation
- **Result**: App switches back to previous app (DApp)

## üîÑ **5. Usage Flow trong App**

### **A. WalletConnect Redirect Flow**
```typescript
// 1. Request completed
approveRequest = async ({ id, result }) => {
  await this.web3Wallet.respondSessionRequest({ topic, response: {...} });
  
  // 2. Check for pending requests
  const hasPendingSignRequest = requests[0]?.params?.request?.method === 'personal_sign';
  
  if (!hasPendingSignRequest) {
    this.needsRedirect(id); // 3. Trigger redirect
  }
};

// 4. Redirect execution
needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    this.redirect(`needsRedirect_${id}`); // 5. Call redirect
  }
};

// 6. Platform-specific redirect
redirect = (context?: string) => {
  if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
    // iOS 17+: Use direct app linking
    Linking.openURL(peerLink);
  } else {
    // Older iOS/Android: Use Minimizer
    Minimizer.goBack(); // üöÄ MINIMIZE TO SHOW DAPP
  }
};
```

### **B. SDK Connection Flow**
```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
const canRedirect = connection.rpcQueueManager.canRedirect({ method });

if (connection.trigger === 'deeplink' && canRedirect) {
  // Show return modal instead of direct minimize
  connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
    screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
  });
}
```

## üéØ **6. Platform Differences**

### **Android:**
- **Simple**: `moveTaskToBack(true)` API
- **Reliable**: Standard Android behavior
- **Backwards Compatible**: Works on all Android versions

### **iOS:**
- **Complex**: Uses private APIs via runtime introspection
- **Version Dependent**: Different behavior on iOS 17+
- **Potential Risk**: Private API usage might break in future iOS versions
- **Alternative**: iOS 17+ uses `Linking.openURL()` with app schemes

## üö® **7. Edge Cases & Considerations**

### **A. Android Background Restrictions**
```kotlin
// MainActivity.kt - Handle back button behavior
override fun invokeDefaultOnBackPressed() {
  if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
    if (!moveTaskToBack(false)) {
      super.invokeDefaultOnBackPressed(); // Fallback
    }
    return;
  }
  super.invokeDefaultOnBackPressed(); // Android S+ default behavior
}
```

### **B. iOS Private API Risks**
- **Apple Review**: Private API usage c√≥ th·ªÉ b·ªã reject
- **iOS Updates**: C√≥ th·ªÉ break trong future iOS versions
- **Graceful Degradation**: Return to DApp modal as fallback

### **C. Connection Type Handling**
```typescript
// Skip redirect for QR code connections
if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // Don't minimize for QR scanned connections
}
```

## üõ†Ô∏è **8. C√°ch t·∫°o Custom Minimizer**

### **A. Create New Native Module**

#### **1. Android Implementation**
```java
// Create new module
public class CustomMinimizer extends ReactContextBaseJavaModule {
  @ReactMethod
  public void minimizeApp() {
    Activity activity = getCurrentActivity();
    if (activity != null) {
      activity.moveTaskToBack(true);
    }
  }
  
  @ReactMethod  
  public void minimizeWithDelay(int delayMs) {
    Handler handler = new Handler(Looper.getMainLooper());
    handler.postDelayed(() -> {
      minimizeApp();
    }, delayMs);
  }
}
```

#### **2. iOS Implementation**
```objc
@implementation CustomMinimizer

RCT_EXPORT_METHOD(minimizeApp)
{
  dispatch_async(dispatch_get_main_queue(), ^{
    // Your custom minimize logic
    [[UIApplication sharedApplication] performSelector:@selector(suspend)];
  });
}

RCT_EXPORT_METHOD(minimizeWithDelay:(NSNumber*)delay)
{
  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, [delay intValue] * NSEC_PER_MSEC), 
                dispatch_get_main_queue(), ^{
    [self minimizeApp];
  });
}

@end
```

### **B. Register Module**
```java
// Package registration
public class CustomMinimizerPackage implements ReactPackage {
  @Override
  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
    List<NativeModule> modules = new ArrayList<>();
    modules.add(new CustomMinimizer(reactContext));
    return modules;
  }
}
```

### **C. Use in JavaScript**
```typescript
import { NativeModules } from 'react-native';
const { CustomMinimizer } = NativeModules;

// Usage
CustomMinimizer.minimizeApp();
CustomMinimizer.minimizeWithDelay(1000); // Delay 1 second
```

**Minimizer** l√† m·ªôt elegant solution ƒë·ªÉ t·∫°o seamless UX cho users khi switch gi·ªØa MetaMask v√† DApps, ƒë·∫∑c bi·ªát quan tr·ªçng cho WalletConnect v√† deeplink flows.

```typescript
// app/core/NativeModules.ts
import { NativeModules } from 'react-native';

// Minimizer module allows the app to be pushed to the background
const { Minimizer } = NativeModules;

export { Minimizer };
```

```typescript
// app/core/WalletConnect/WalletConnect2Session.ts
import { Minimizer } from '../NativeModules';

redirect = (context?: string) => {
  setTimeout(() => {
    if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
      // iOS 17+ specific logic
    } else {
      Minimizer.goBack(); // üöÄ MINIMIZE APP
    }
  }, 100);
};
```

```java
// android/app/src/main/java/io/metamask/nativeModules/RCTMinimizer.java
package io.metamask.nativeModules;

import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;

public class RCTMinimizer extends ReactContextBaseJavaModule {
  private ReactApplicationContext reactContext;
  
  RCTMinimizer(ReactApplicationContext context) {
    super(context);
    this.reactContext = context;
  }

  @Override
  public String getName() {
    return "Minimizer"; // üìå T√™n module accessible t·ª´ JS
  }

  @ReactMethod
  public void goBack() {
    android.app.Activity activity = getCurrentActivity();
    if (activity != null) {
      activity.moveTaskToBack(true); // üöÄ MOVE TO BACKGROUND
    }
  }
}
```

```java
// android/app/src/main/java/io/metamask/nativeModules/RCTMinimizerPackage.java
public class RCTMinimizerPackage implements ReactPackage {
  @Override
  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
    List<NativeModule> modules = new ArrayList<>();
    modules.add(new RCTMinimizer(reactContext)); // üìå Register module
    return modules;
  }
}
```

```kotlin
// android/app/src/main/java/io/metamask/MainApplication.kt
import io.metamask.nativeModules.RCTMinimizerPackage

class MainApplication : Application(), ReactApplication {
  override val reactNativeHost: ReactNativeHost = ReactNativeHostWrapper(
    this,
    object : DefaultReactNativeHost(this) {
      override fun getPackages(): List<ReactPackage> {
        val packages = PackageList(this).packages.toMutableList()
        packages.add(RCTMinimizerPackage()) // üöÄ ADD MINIMIZER PACKAGE
        return packages
      }
    }
  )
}
```

```plaintext
// ios/MetaMask/NativeModules/RCTMinimizer/RCTMinimizer.h
#import <React/RCTBridgeModule.h>

@interface RCTMinimizer : NSObject <RCTBridgeModule>
@end
```

```plaintext
// ios/MetaMask/NativeModules/RCTMinimizer/RCTMinimizer.m
#import "RCTMinimizer.h"
#import <UIKit/UIKit.h>
#import <objc/runtime.h>

@interface UISystemNavigationAction : NSObject
@property(nonatomic, readonly, nonnull) NSArray<NSNumber*>* destinations;
-(BOOL)sendResponseForDestination:(NSUInteger)destination;
@end

@implementation RCTMinimizer

RCT_EXPORT_METHOD(goBack)
{
  // üöÄ ACCESS PRIVATE iOS API ƒë·ªÉ minimize app
  Ivar sysNavIvar = class_getInstanceVariable(UIApplication.class, "_systemNavigationAction");
  UIApplication* app = UIApplication.sharedApplication;
  UISystemNavigationAction* action = object_getIvar(app, sysNavIvar);
  
  if (!action) {
      return;
  }
  
  NSUInteger destination = action.destinations.firstObject.unsignedIntegerValue;
  [action sendResponseForDestination:destination]; // üöÄ NAVIGATE BACK
}

RCT_EXPORT_MODULE(); // üìå Register v·ªõi React Native bridge

@end
```

```java
activity.moveTaskToBack(true);
```

```plaintext
// Access private UISystemNavigationAction
UISystemNavigationAction* action = object_getIvar(app, sysNavIvar);
[action sendResponseForDestination:destination];
```

```typescript
// 1. Request completed
approveRequest = async ({ id, result }) => {
  await this.web3Wallet.respondSessionRequest({ topic, response: {...} });
  
  // 2. Check for pending requests
  const hasPendingSignRequest = requests[0]?.params?.request?.method === 'personal_sign';
  
  if (!hasPendingSignRequest) {
    this.needsRedirect(id); // 3. Trigger redirect
  }
};

// 4. Redirect execution
needsRedirect = (id: string) => {
  if (this.requestsToRedirect[id]) {
    this.redirect(`needsRedirect_${id}`); // 5. Call redirect
  }
};

// 6. Platform-specific redirect
redirect = (context?: string) => {
  if (Device.isIos() && parseInt(Platform.Version as string) >= 17) {
    // iOS 17+: Use direct app linking
    Linking.openURL(peerLink);
  } else {
    // Older iOS/Android: Use Minimizer
    Minimizer.goBack(); // üöÄ MINIMIZE TO SHOW DAPP
  }
};
```

```typescript
// app/core/SDKConnect/handlers/handleSendMessage.ts
const canRedirect = connection.rpcQueueManager.canRedirect({ method });

if (connection.trigger === 'deeplink' && canRedirect) {
  // Show return modal instead of direct minimize
  connection.navigation?.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {
    screen: Routes.SHEET.RETURN_TO_DAPP_MODAL,
  });
}
```

```kotlin
// MainActivity.kt - Handle back button behavior
override fun invokeDefaultOnBackPressed() {
  if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.R) {
    if (!moveTaskToBack(false)) {
      super.invokeDefaultOnBackPressed(); // Fallback
    }
    return;
  }
  super.invokeDefaultOnBackPressed(); // Android S+ default behavior
}
```

```typescript
// Skip redirect for QR code connections
if (this.requestOriginatedFrom === AppConstants.DEEPLINKS.ORIGIN_QR_CODE) {
  return; // Don't minimize for QR scanned connections
}
```

```java
// Create new module
public class CustomMinimizer extends ReactContextBaseJavaModule {
  @ReactMethod
  public void minimizeApp() {
    Activity activity = getCurrentActivity();
    if (activity != null) {
      activity.moveTaskToBack(true);
    }
  }
  
  @ReactMethod  
  public void minimizeWithDelay(int delayMs) {
    Handler handler = new Handler(Looper.getMainLooper());
    handler.postDelayed(() -> {
      minimizeApp();
    }, delayMs);
  }
}
```

```plaintext
@implementation CustomMinimizer

RCT_EXPORT_METHOD(minimizeApp)
{
  dispatch_async(dispatch_get_main_queue(), ^{
    // Your custom minimize logic
    [[UIApplication sharedApplication] performSelector:@selector(suspend)];
  });
}

RCT_EXPORT_METHOD(minimizeWithDelay:(NSNumber*)delay)
{
  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, [delay intValue] * NSEC_PER_MSEC), 
                dispatch_get_main_queue(), ^{
    [self minimizeApp];
  });
}

@end
```

```java
// Package registration
public class CustomMinimizerPackage implements ReactPackage {
  @Override
  public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
    List<NativeModule> modules = new ArrayList<>();
    modules.add(new CustomMinimizer(reactContext));
    return modules;
  }
}
```

```typescript
import { NativeModules } from 'react-native';
const { CustomMinimizer } = NativeModules;

// Usage
CustomMinimizer.minimizeApp();
CustomMinimizer.minimizeWithDelay(1000); // Delay 1 second
```

